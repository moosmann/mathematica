(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input:: *)
Clear[lineplot3d,erplot,evoplot3d,cenplot,cenplot3d,multicenplot3d,meancenplot,meancenplot3d];

erplot[sol_List,tt1_:0,tt2_:100]:=
Module[{t1,t2},
{t1,t2}=First[First[sol][[2]]][[1]];
If[tt1>t1,t1=tt1];
If[tt2<t2  ,t2=tt2];
Plot[{error[sol,t]},{t,t1,t2},PerformanceGoal->"Speed"]
];

evoplot3d[num_Integer,scale_:3,opts___]:=
Module[{sol,n,curplot,lineplots},
sol=Subscript[solution, num];
n=Length[sol];

curplot=ParametricPlot3D[
{{scale Subscript[curve, num][u][[1]],scale  Subscript[curve, num][u][[2]],0},{0,0,100}},
{u,0,2\[Pi]},PlotRange->All,PerformanceGoal->"Speed",opts];
lineplots=Table[lineplot3d[sol[[i]],scale,PlotStyle->{{Black,Thin}}],{i,1,n}];

Show[curplot,lineplots]
];

cenplot[num_,t1_:0,t2_:99.9]:=
ParametricPlot[centroid[num,t],{t,t1,t2},PerformanceGoal->"Speed",PlotRange->Full];

cenplot3d[num_,scale_:10,opts___]:=
Show[
evoplot3d[num,scale,opts],ParametricPlot3D[{scale centroid[num,t][[1]],scale centroid[num,t][[2]],t},{t,0,99.9},PerformanceGoal->"Speed",PlotRange->Full,PlotStyle->{Thick,Black}]
];

multicenplot3d[n_,scale_:3,opts___]:=ParametricPlot3D[Table[Flatten[{scale centroid[i,t],t}],{i,1,n}],{t,0,99.5},PerformanceGoal->"Speed",opts];

c2plot[n_,opts___]:=
Plot[{(c[t]/.Subscript[zsol, n][[1]])^2},{t,0,99.9},PlotRange->All,opts];

meancenplot3d[num_]:=
ParametricPlot3D[Flatten[{ meancen[num,t],t/100}],{t,0,99},PlotRange->All,PerformanceGoal->"Speed",MaxRecursion->2];

meancenplot[n_]:=
ParametricPlot[Table[meancen[i,t],{i,1,n}],{t,0,99},PlotRange->All,PerformanceGoal->"Speed",MaxRecursion->1,PlotStyle->{Red,Blue}];


(* ::Input:: *)
Clear[cut];

cut[sol_List]:=
Module[{n,t1,t2,grid,X1,Y1,X2,Y2,fddf,
dist,dmin,l1,l2,l,i,j,d,
newdist,nnew,newX,newY,newgrid},

{t1,t2}=First[First[sol][[2]]][[1]]-{0,1};
n=Length[sol]/2-1;
grid=Range[0,n];
fddf = NDSolve`FiniteDifferenceDerivative[Derivative[1], grid];

X1=Through[Thread[Subscript[x, grid]][t1]]/.sol;
Y1=Through[Thread[Subscript[y, grid]][t1]]/.sol;
dist=Sqrt[fddf[X1]^2 +fddf[Y1]^2];
l1=Total[Drop[dist,1]];
dmin=1Min@dist;

X2=Through[Thread[Subscript[x, grid]][t2]]/.sol;
Y2=Through[Thread[Subscript[y, grid]][t2]]/.sol;
dist=Sqrt[fddf[X2]^2 +fddf[Y2]^2];
l2=Total[Drop[dist,1]];

newdist=Reap[
For[i=1;j=0,i<= n,i++,
d=Sum[dist[[m]],{m,j+1,i}];
If[i==n,Sow[{i,d}];Break[],None,Print["Error while fitting: Break at i=n"]];
If[d>= dmin,j=i;Sow[{i,d}],None,Print["Error while fitting: Sow for d>dmin"]];
];
][[2,1]];
nnew=Length[newdist];

If[l2!=Total[newdist[[All,2]]],Print["Error after fitting: Fitted length unequal original length"];
];
Subscript[l, 0]=0;
Do[Subscript[l, i]=Subscript[l, i-1]+newdist[[i,2]],{i,1,nnew}];

newX=Through[Thread[Subscript[x, newdist[[All,1]]]][t2]]/.sol;
newY=Through[Thread[Subscript[y, newdist[[All,1]]]][t2]]/.sol;
newgrid=Table[{2\[Pi] Subscript[l, i]/l2,{newX[[i]],newY[[i]]}},{i,1,nnew}];
Prepend[newgrid,{0,Last[newgrid][[2]]}]

]


Clear[zpde];
zpde[n_]:=
Block[{clist=Range[1,n],noc,pde,bc,c},
noc=Length[clist];
z[t_]:=Sum[Exp[-Subscript[iso, num][t](1+c[t]/Subscript[l, num][t])],{num,clist}];
pde=Evaluate[\!\(
\*SubscriptBox[\(\[PartialD]\), \(t\)]\(z[t]\)\)] ==0;
bc=Sum[Subscript[l, num][t] Exp[-Subscript[iso, num][0](1+c[t]/Subscript[l, num][t])] /.t->0,{num,clist}]/z[0]==Sum[Subscript[l, num][t]/.t->0,{num,clist}]/noc;
Subscript[co, noc]=c[0]/.FindRoot[bc,{c[0],-290}];
Print[{noc,Subscript[co, noc]}];

Timing[Subscript[zsol, noc]=NDSolve[{pde,c[0]==Subscript[co, noc]},c,{t,0,99.9}]]//Print;
]


Clear[c2fit,vtab,ktab];

c2fit[n_Integer,t1_,t2_,pts_:50]:=
Block[{data,expr,pars,cf},
data=Table[{t1 +(t2-t1)i/pts,(c[t1 +(t2-t1)i/pts]/.Subscript[zsol, n][[1]])^2},{i,0,pts}];
expr=k Abs[(100-t)]^v;
pars={{k,400},{v,1}};
cf=FindFit[data,expr,pars,t];
{Sqrt[k],v/2}/.cf
];

vtab[n_Integer,t1_,t2_,int_:10]:=
Quiet[
TableForm[Table[c2fit[i,t1+(t2-t1)( j-1)/int,t1+(t2-t1) j/int][[2]],{j,1,int},{i,1,n}],
TableHeadings->{Table[{t1+(t2-t1)( j-1)/int,t1+(t2-t1) j/int},{j,1,int}],Table[i,{i,1,n}]}]
];

ktab[n_Integer,t1_,t2_,int_:10]:=
Quiet[
TableForm[Table[c2fit[i,t1+(t2-t1)( j-1)/int,t1+(t2-t1) j/int][[1]],{j,1,int},{i,1,n}],
TableHeadings->{Table[{t1+(t2-t1)( j-1)/int,t1+(t2-t1) j/int},{j,1,int}],Table[i,{i,1,n}]}]
]


Clear[meancen,varcen];
meancen[n_,t_]:=
Sum[centroid[num,t] Exp[-action[n,num,t]],{num,1,n}]/Sum[Exp[-action[n,num,t]],{num,1,n}];

varcen[n_,t_]:=
Sqrt[
Sum[centroid[num,t]^2 Exp[-action[n,num,t]],{num,1,n}]/Sum[Exp[-action[n,num,t]],{num,1,n}]-meancen[n,t]^2
];

varcen2[n_,t_]:=
Sqrt[
Sum[(centroid[num,t]-meancen[n,t])^2 Exp[-action[n,num,t]],{num,1,n}]/Sum[Exp[-action[n,num,t]],{num,1,n}]
];



